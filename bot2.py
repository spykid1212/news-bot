import logging
import os
import asyncio
import time
from dotenv import load_dotenv
from telegram import Update
from telegram.ext import Application, CommandHandler, ContextTypes
import requests
from bs4 import BeautifulSoup
import datetime
import re
from collections import Counter

# T·∫£i bi·∫øn m√¥i tr∆∞·ªùng t·ª´ file .env
load_dotenv()
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")

# C·∫•u h√¨nh logging
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# ƒê·ªãnh nghƒ©a ngu·ªìn tin t·ª©c
NEWS_SOURCES = {
    "vnexpress": {
        "url": "https://vnexpress.net/suc-khoe",
        "article_selector": "article.item-news",
        "title_selector": "h3.title-news a"
    },
    "dantri": {
        "url": "https://dantri.com.vn/suc-khoe.htm",
        "article_selector": "article.article-item",
        "title_selector": "h3.article-title a"
    },
    "thanhnien": {
        "url": "https://thanhnien.vn/suc-khoe.htm",
        "article_selector": "div.relative",
        "title_selector": "h3.title a"
    },
    "nld": {
        "url": "https://nld.com.vn/suc-khoe.htm",
        "article_selector": "div.item-news",
        "title_selector": "h3.title-news a"
    },
    "suckhoedoisong": {
        "url": "https://suckhoedoisong.vn",
        "article_selector": "article.item-news",
        "title_selector": "h3.title-news a"
    },
    "tuoitre": {
        "url": "https://tuoitre.vn/suc-khoe.htm",
        "article_selector": "div.news-item",
        "title_selector": "h3.title a"
    },
    "znews": {
        "url": "https://lifestyle.znews.vn/suc-khoe.html",
        "article_selector": "article.article-item",
        "title_selector": "h3.article-title a"
    },
    "vietnamnet": {
        "url": "https://vietnamnet.vn/suc-khoe",
        "article_selector": "div.item-news",
        "title_selector": "h3.title a"
    },
    "doisongphapluat": {
        "url": "https://doisongphapluat.com.vn/y-te-167.html",
        "article_selector": "div.news-item",
        "title_selector": "h3.title a"
    }
}

# ƒê·ªãnh nghƒ©a t·ª´ kh√≥a gh√©p v√† t·ª´ kh√≥a y t·∫ø quan tr·ªçng
COMPOUND_KEYWORDS = {
    'b·ªánh n·ªÅn', 'c√∫m a', 'covid-19', 's·ªët xu·∫•t huy·∫øt', 'ti·ªÉu ƒë∆∞·ªùng', 'huy·∫øt √°p cao',
    'ung th∆∞ ph·ªïi', 'vi√™m gan', 'ƒëau ƒë·∫ßu', 'r·ªëi lo·∫°n', 't√¢m th·∫ßn', 'tim m·∫°ch',
    'x∆∞∆°ng kh·ªõp', 'da li·ªÖu', 'rƒÉng mi·ªáng', 'tai m≈©i h·ªçng', 'h√¥ h·∫•p', 'ti√™u h√≥a',
    'th·∫ßn kinh', 'n·ªôi ti·∫øt', 'dinh d∆∞·ª°ng', 'y t·∫ø', 's·ª©c kh·ªèe', 'ƒëi·ªÅu tr·ªã',
    'ph√≤ng b·ªánh', 'thu·ªëc men', 'vaccine', 'ti√™m ch·ªßng', 'x√©t nghi·ªám',
    'chƒÉm s√≥c', 'ph·∫´u thu·∫≠t', 'c·∫•p c·ª©u', 'nhi·ªÖm khu·∫©n', 'kh√°ng sinh',
    'd·ªã ·ª©ng', 'tr·∫ßm c·∫£m', 'm√£n t√≠nh', 'bi·∫øn ch·ª©ng', 'ng·ªô ƒë·ªôc'
}

HEALTH_KEYWORDS = {
    's·ª©c kh·ªèe', 'b·ªánh', 'thu·ªëc', 'ƒëi·ªÅu tr·ªã', 'tri·ªáu ch·ª©ng', 'virus',
    'vaccine', 'ti√™m ch·ªßng', 'ung th∆∞', 'tim m·∫°ch', 'huy·∫øt √°p',
    's·ªët', 'vi√™m', 'nhi·ªÖm', 'd·ªãch', 'x√©t nghi·ªám',
    'thai k·ª≥', 'sinh l√Ω', 'dinh d∆∞·ª°ng', 'vitamin', 't·∫≠p luy·ªán',
    'covid', 'd·ªãch b·ªánh', 'th·ª±c ph·∫©m', 'b√©o ph√¨',
    'ti·ªÉu ƒë∆∞·ªùng', 'h√¥ h·∫•p', 'da li·ªÖu', 'rƒÉng mi·ªáng', 'th·∫ßn kinh',
    't√¢m l√Ω', 'stress', 't·ª≠ vong', 'kh√°m b·ªánh', 'ph√≤ng b·ªánh',
    'y t·∫ø', 'b√°c sƒ©', 'b·ªánh vi·ªán', 'ph√≤ng kh√°m', 'c·∫•p c·ª©u',
    'thu·ªëc', 'ƒëi·ªÅu d∆∞·ª°ng', 'chƒÉm s√≥c', 'ph·∫´u thu·∫≠t', 'x∆∞∆°ng kh·ªõp'
}

class NewsBot:
    def __init__(self):
        self.cached_news = []
        self.last_update = None
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
    
    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """X·ª≠ l√Ω l·ªánh /start"""
        welcome_message = """
        üëã Xin ch√†o! T√¥i l√† bot t√¨m ki·∫øm tin t·ª©c s·ª©c kh·ªèe üè•
        
        C√°c l·ªánh c√≥ s·∫µn:
        /news - L·∫•y tin t·ª©c m·ªõi nh·∫•t
        /keywords - Xem c√°c t·ª´ kh√≥a hot
        /help - Hi·ªÉn th·ªã tr·ª£ gi√∫p
        """
        await update.message.reply_text(welcome_message)

    async def help(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """X·ª≠ l√Ω l·ªánh /help"""
        help_text = """
        ü§ñ C√°c l·ªánh c√≥ s·∫µn:
        
        /news - L·∫•y tin t·ª©c m·ªõi nh·∫•t t·ª´ c√°c b√°o uy t√≠n
        /keywords - Xem c√°c t·ª´ kh√≥a hot v·ªÅ s·ª©c kh·ªèe
        /help - Hi·ªÉn th·ªã tr·ª£ gi√∫p n√†y
        
        üìù Ch√∫ √Ω:
        - Tin t·ª©c ƒë∆∞·ª£c c·∫≠p nh·∫≠t m·ªói 24 gi·ªù
        - T·ª´ kh√≥a ƒë∆∞·ª£c ph√¢n t√≠ch t·ª´ c√°c tin t·ª©c m·ªõi nh·∫•t
        """
        await update.message.reply_text(help_text)

    def crawl_single_source(self, source_name, source_info):
        """Crawl tin t·ª©c t·ª´ m·ªôt ngu·ªìn c·ª• th·ªÉ v·ªõi x·ª≠ l√Ω l·ªói chi ti·∫øt"""
        try:
            response = requests.get(source_info['url'], headers=self.headers, timeout=10)
            response.raise_for_status()
            
            soup = BeautifulSoup(response.text, 'html.parser')
            articles = soup.select(source_info['article_selector'])
            
            if not articles:
                logger.warning(f"Kh√¥ng t√¨m th·∫•y b√†i vi·∫øt n√†o t·ª´ {source_name} v·ªõi selector: {source_info['article_selector']}")
                return []
            
            news_items = []
            for article in articles[:5]:  # L·∫•y 5 b√†i m·ªõi nh·∫•t
                title_element = article.select_one(source_info['title_selector'])
                if title_element and title_element.text:
                    title = title_element.text.strip()
                    title = re.sub(r'\s+', ' ', title)
                    
                    # Th√™m URL c·ªßa b√†i vi·∫øt n·∫øu c√≥
                    url = ""
                    if title_element.has_attr('href'):
                        url = title_element['href']
                        # X·ª≠ l√Ω URL t∆∞∆°ng ƒë·ªëi
                        if url.startswith('/'):
                            base_url = '/'.join(source_info['url'].split('/')[:3])
                            url = base_url + url
                    
                    news_items.append({
                        'title': title,
                        'source': source_name,
                        'url': url,
                        'timestamp': datetime.datetime.now()
                    })
            
            logger.info(f"ƒê√£ crawl th√†nh c√¥ng {len(news_items)} b√†i t·ª´ {source_name}")
            return news_items
            
        except requests.exceptions.RequestException as e:
            logger.error(f"L·ªói k·∫øt n·ªëi khi crawl t·ª´ {source_name}: {str(e)}")
        except Exception as e:
            logger.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi crawl t·ª´ {source_name}: {str(e)}")
        return []

    def crawl_news(self):
        """Crawl tin t·ª©c t·ª´ t·∫•t c·∫£ c√°c ngu·ªìn"""
        all_news = []
        for source_name, source_info in NEWS_SOURCES.items():
            source_news = self.crawl_single_source(source_name, source_info)
            all_news.extend(source_news)
            time.sleep(1)  # Delay gi·ªØa c√°c request
        
        source_counts = Counter(news['source'] for news in all_news)
        logger.info(f"T·ªïng s·ªë tin t·ª©c ƒë√£ crawl: {len(all_news)}")
        logger.info(f"Ph√¢n b·ªë theo ngu·ªìn: {dict(source_counts)}")
        
        return all_news

    def get_keywords(self, texts):
        """Tr√≠ch xu·∫•t t·ª´ kh√≥a v·ªõi c√°ch x·ª≠ l√Ω vƒÉn b·∫£n c·∫£i ti·∫øn"""
        try:
            # T·ª´ d·ª´ng ti·∫øng Vi·ªát
            vietnamese_stop_words = set([
                'v√†', 'c·ªßa', 'c√≥', 'ƒë∆∞·ª£c', 'trong', 'ƒë√£', 'v·ªõi', 'c√°c', 'nh·ªØng',
                'ƒë·ªÉ', 'l√†', 'm·ªôt', 'kh√¥ng', 'n√†y', 'cho', 'khi', 'ƒë·∫øn', 'v·ªÅ',
                'nh∆∞', 't·ª´', 'ng∆∞·ªùi', 'ra', 's·∫Ω', 'c·∫ßn', 'ph·∫£i', 't·∫°i', 'trong',
                'theo', 'ƒë∆∞·ª£c', 'nh∆∞ng', 'v√¨', 'do', 'ƒëang', 's·∫Ω', 'n√™n', 'c√≤n',
                'th·∫ø', 'n√†o', 'g√¨', 'b·ªã', 'sau', 'v·ªÅ', 'l√†m', 'm·ªõi', 'ai',
                'bi·∫øt', 'n·∫øu', 'th√¨', 'ƒë√¢y', 'khi', 'r·∫•t', 'l√∫c', 'v·ª´a', 'ƒë·ªÅ',
                'nƒÉm', 'qua', 'hay', 'tr√™n', 'd∆∞·ªõi', 't·ªõi', 'ƒë·ªÅu', 'vi·ªác'
            ])

            keyword_counts = Counter()

            # B∆∞·ªõc 1: Tr√≠ch xu·∫•t t·ª´ gh√©p t·ª´ ti√™u ƒë·ªÅ
            for text in texts:
                # Chu·∫©n h√≥a text
                text = text.lower()
                text = re.sub(r'[.,!?:]', ' ', text)
                
                # T√¨m t·ª´ gh√©p ƒë·∫ßu ti√™n
                for compound_keyword in COMPOUND_KEYWORDS:
                    if compound_keyword in text:
                        keyword_counts[compound_keyword] += 1
            
            # B∆∞·ªõc 2: X·ª≠ l√Ω l·∫°i ti√™u ƒë·ªÅ ƒë·ªÉ t√¨m t·ª´ kh√≥a ƒë∆°n v√† c·∫∑p t·ª´
            for text in texts:
                # Chu·∫©n h√≥a text
                text = text.lower()
                text = re.sub(r'[.,!?:]', ' ', text)
                
                # T√°ch c√¢u th√†nh t·ª´
                words = text.split()
                
                # X·ª≠ l√Ω t·ª´ng t·ª´ ƒë∆°n trong HEALTH_KEYWORDS
                for word in words:
                    if word in HEALTH_KEYWORDS and word not in vietnamese_stop_words:
                        keyword_counts[word] += 1
                
                # X·ª≠ l√Ω t·ª´ng c·∫∑p t·ª´ li√™n ti·∫øp
                for i in range(len(words) - 1):
                    bigram = ' '.join(words[i:i+2])
                    # Ki·ªÉm tra bigram c√≥ ch·ª©a t·ª´ kh√≥a s·ª©c kh·ªèe kh√¥ng
                    if any(keyword in bigram for keyword in HEALTH_KEYWORDS):
                        if not any(word in vietnamese_stop_words for word in words[i:i+2]):
                            keyword_counts[bigram] += 1
                
                # X·ª≠ l√Ω t·ª´ng b·ªô ba t·ª´ li√™n ti·∫øp
                for i in range(len(words) - 2):
                    trigram = ' '.join(words[i:i+3])
                    # Ki·ªÉm tra trigram c√≥ ch·ª©a t·ª´ kh√≥a s·ª©c kh·ªèe kh√¥ng
                    if any(keyword in trigram for keyword in HEALTH_KEYWORDS):
                        if not all(word in vietnamese_stop_words for word in words[i:i+3]):
                            keyword_counts[trigram] += 1

            # L·ªçc k·∫øt qu·∫£: ch·∫•p nh·∫≠n t·ª´ kh√≥a xu·∫•t hi·ªán √≠t nh·∫•t 1 l·∫ßn v√† lo·∫°i b·ªè t·ª´ qu√° ng·∫Øn
            valid_keywords = [(k, v) for k, v in keyword_counts.items() if len(k) > 1]
            
            # ∆Øu ti√™n t·ª´ kh√≥a theo t·∫ßn su·∫•t xu·∫•t hi·ªán v√† ƒë·ªô d√†i
            sorted_keywords = sorted(valid_keywords, 
                                  key=lambda x: (x[1], len(x[0].split())), 
                                  reverse=True)
            
            logger.info(f"S·ªë l∆∞·ª£ng t·ª´ kh√≥a t√¨m ƒë∆∞·ª£c: {len(sorted_keywords)}")
            logger.info(f"C√°c t·ª´ kh√≥a: {sorted_keywords[:10]}")
            
            return sorted_keywords[:10]  # Tr·∫£ v·ªÅ 10 t·ª´ kh√≥a h√†ng ƒë·∫ßu

        except Exception as e:
            logger.error(f"L·ªói khi tr√≠ch xu·∫•t t·ª´ kh√≥a: {str(e)}")
            logger.exception(e)
            return []

    async def get_news(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """X·ª≠ l√Ω l·ªánh /news - Hi·ªÉn th·ªã c√°c b√†i b√°o ƒë√£ crawl"""
        try:
            await update.message.reply_text("üîç ƒêang t√¨m ki·∫øm tin t·ª©c s·ª©c kh·ªèe m·ªõi...")
            
            current_time = datetime.datetime.now()
            if not self.last_update or (current_time - self.last_update).seconds > 86400:
                self.cached_news = self.crawl_news()
                self.last_update = current_time
            
            if not self.cached_news:
                await update.message.reply_text("‚ùå Kh√¥ng t√¨m th·∫•y tin t·ª©c n√†o. Vui l√≤ng th·ª≠ l·∫°i sau.")
                return
            
            # Ph√¢n lo·∫°i tin t·ª©c theo ngu·ªìn
            news_by_source = {}
            for news in self.cached_news:
                source = news['source']
                if source not in news_by_source:
                    news_by_source[source] = []
                news_by_source[source].append(news)
            
            # T·∫°o message hi·ªÉn th·ªã tin t·ª©c
            message = "üì∞ TIN T·ª®C S·ª®C KH·ªéE M·ªöI NH·∫§T\n\n"
            
            # Th√™m tin t·ª©c t·ª´ m·ªói ngu·ªìn v√†o message
            for source, news_list in news_by_source.items():
                message += f"üîπ {source.upper()}:\n"
                for idx, news in enumerate(news_list[:5], 1):  # Hi·ªÉn th·ªã t·ªëi ƒëa 5 tin t·ª´ m·ªói ngu·ªìn
                    title = news['title']
                    url = news['url'] if 'url' in news and news['url'] else "Kh√¥ng c√≥ URL"
                    message += f"  {idx}. {title}\n"
                    if url != "Kh√¥ng c√≥ URL":
                        message += f"     üëâ {url}\n"
                message += "\n"
            
            # Th√™m th·ªùi gian c·∫≠p nh·∫≠t
            message += f"‚è∞ C·∫≠p nh·∫≠t: {self.last_update.strftime('%d/%m/%Y %H:%M')}"
            
            await update.message.reply_text(message)
        except Exception as e:
            logger.error(f"L·ªói khi l·∫•y tin t·ª©c: {str(e)}")
            logger.exception(e)
            await update.message.reply_text("‚ùå C√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i sau.")

    async def get_keywords_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """X·ª≠ l√Ω l·ªánh /keywords"""
        try:
            await update.message.reply_text("üîç ƒêang ph√¢n t√≠ch t·ª´ kh√≥a s·ª©c kh·ªèe n·ªïi b·∫≠t...")
            
            current_time = datetime.datetime.now()
            if not self.last_update or (current_time - self.last_update).seconds > 86400:
                self.cached_news = self.crawl_news()
                self.last_update = current_time
            
            if not self.cached_news:
                await update.message.reply_text("‚ùå Kh√¥ng t√¨m th·∫•y tin t·ª©c n√†o. Vui l√≤ng th·ª≠ l·∫°i sau.")
                return
            
            titles = [news['title'] for news in self.cached_news]
            keywords = self.get_keywords(titles)
            
            if not keywords:
                await update.message.reply_text("‚ùå Kh√¥ng t√¨m th·∫•y t·ª´ kh√≥a ph√π h·ª£p. Vui l√≤ng th·ª≠ l·∫°i sau.")
                return
            
            response = "üî• C√°c t·ª´ kh√≥a n·ªïi b·∫≠t v·ªÅ s·ª©c kh·ªèe:\n\n"
            for word, count in keywords:
                # Th√™m emoji ph√π h·ª£p cho t·ª´ng lo·∫°i t·ª´ kh√≥a
                emoji = "üè•" if word in COMPOUND_KEYWORDS else "üìä"
                response += f"{emoji} {word}: {count} l·∫ßn\n"
            
            # Th√™m ch√∫ th√≠ch
            response += "\nüí° Ch√∫ th√≠ch:\n"
            response += "üè• - T·ª´ kh√≥a y t·∫ø quan tr·ªçng\n"
            response += "üìä - T·ª´ kh√≥a ph·ªï bi·∫øn kh√°c"
            
            await update.message.reply_text(response)
        except Exception as e:
            logger.error(f"L·ªói khi l·∫•y t·ª´ kh√≥a: {str(e)}")
            await update.message.reply_text("‚ùå C√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i sau.")

    async def error_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """X·ª≠ l√Ω l·ªói chung cho bot"""
        logger.error(f"L·ªói khi x·ª≠ l√Ω update {update}: {context.error}")
        try:
            if update and update.message:
                await update.message.reply_text(
                    "‚ùå C√≥ l·ªói x·∫£y ra khi x·ª≠ l√Ω y√™u c·∫ßu c·ªßa b·∫°n. Vui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c li√™n h·ªá admin."
                )
        except Exception as e:
            logger.error(f"L·ªói khi g·ª≠i th√¥ng b√°o l·ªói: {e}")

def main():
    """Kh·ªüi ƒë·ªông bot"""
    try:
        # Kh·ªüi t·∫°o ·ª©ng d·ª•ng v·ªõi token
        application = Application.builder().token(TELEGRAM_TOKEN).build()
        
        # Kh·ªüi t·∫°o bot
        bot = NewsBot()

        # Th√™m c√°c handler x·ª≠ l√Ω l·ªánh
        application.add_handler(CommandHandler("start", bot.start))
        application.add_handler(CommandHandler("help", bot.help))
        application.add_handler(CommandHandler("news", bot.get_news))
        application.add_handler(CommandHandler("keywords", bot.get_keywords_command))
        
        # Th√™m error handler
        application.add_error_handler(bot.error_handler)

        # Log khi bot kh·ªüi ƒë·ªông
        logger.info("Bot ƒë√£ s·∫µn s√†ng v√† b·∫Øt ƒë·∫ßu polling...")
        
        # Ch·∫°y bot
        application.run_polling(allowed_updates=Update.ALL_TYPES)
        
    except Exception as e:
        logger.error(f"L·ªói kh·ªüi ƒë·ªông bot: {str(e)}")
        raise

if __name__ == "__main__":
    main()